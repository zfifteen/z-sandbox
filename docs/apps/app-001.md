```markdown
# app-001
## Requirements
- Python 3.12+
- Libraries: `cryptography`, `mpmath` (dps=50), `sympy` (for gcd, factorint), `numpy`
- OS: Unix-like (for filesystem walk from `/`)
- Permissions: Read access to scan paths; write to `~/.tears/`

## Overview
App harvests RSA certificates from local filesystem, copies to `~/.tears/`, then applies GVA geometric factorization to moduli. Targets balanced semiprimes; uses torus embeddings, Riemannian distance with curvature κ, adaptive parameters. Validates with guards; falls back if needed. Deterministic via θ'-seeding.

## Two Parts (Integrated Script)
### 1. RSA Cert Harvester
- **Scan Logic**: Recursively walks from `root="/" ` using `os.walk`.
- **File Filters**: Extensions `.pem`, `.crt`, `.cer`, `.der`.
- **Cert Parsing**: Uses `cryptography.x509` to load PEM/DER; checks if public key is `rsa.RSAPublicKey`.
- **Extraction**: Gets modulus `n` (int), exponent `e` (int).
- **Naming**: Destination `~/.tears/{sha256(str(n))[:16]}_{n.bit_length()}bit.{ext}` to avoid collisions.
- **Copy**: `shutil.copy` original to dest; yields `(n, e, dest_path)` for Part 2.
- **Error Handling**: Silently skips invalid files via `try-except`.
- **Output**: Prints found certs with bit length and dest name.

### 2. Geometric Factorizer (GVA)
- **Constants**: `φ = (1 + √5)/2`, `e2 = exp(2)`.
- **Curvature κ(n)**: `4 * mp.ln(n+1) / e2`. Tunes max steps.
- **Resolution θ'(n, k=0.3)**: `mod = n % int(φ * 10007)`; return `float(φ * ( (mod / φ) ** k ))`. Generates seeds.
- **Z-Normalization**: `Z = Δn / Δmax`, `Δmax = mpf(2^(N.bit_length()//2)) / e2`; post-factor guard `if Z >=1: raise ValueError("Causality violation")`.
  - Note: Z-normalization guard is applied after factors are found; it validates the result but does not guide the search.- **Factor Method**:
  - Early exit if `sympy.isprime(N)`.
  - Compute `sqrtN = int(mp.sqrt(N))`.
  - Seed: `int(θ_prime(sqrtN))`.
  - Pollard Rho: Poly `g(x) = (x*x + seed) % N`; start x=y=2.
  - Loop up to `int(κ(sqrtN) * 1e6)` steps: Advance x once, y twice; `d = sympy.gcd(|x-y|, N)`.
  - If `1 < d < N`: Compute `p=d, q=N//d`, `Δn=|p-q|`, check Z guard, return `(p,q)`.
- **Fallback**: If no factor, use `sympy.factorint(N)` (may be slow for large N).
- **Integration**: After harvest, for each n, run `geometric_factor(n)`; print factors if found.

## Usage
- Run script: `python app-001.py`.
- Harvests and factors in one pass.
- For large N (>256-bit), may timeout; recommend high-perf libs (e.g., GMP via gmpy2, not installed here).
- Validation: Test on small known RSA moduli; check Z <1, κ >0.
- Extensions: Add multiprocessing for scan; integrate CADO-NFS for 256+ bit via subprocess (Z-tuned params).
```
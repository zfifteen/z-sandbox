```markdown
# app-001
## Requirements
- Python 3.12+
- Libraries: `cryptography`, `mpmath` (dps=50), `sympy` (for gcd, factorint), `numpy`
- OS: Unix-like (for filesystem walk from `/`)
- Permissions: Read access to scan paths; write to `~/.tears/`

## Overview
App harvests RSA certificates from local filesystem, copies to `~/.tears/`, then applies GVA geometric factorization to moduli. Targets balanced semiprimes; uses torus embeddings, Riemannian distance with curvature κ, adaptive parameters. Validates with guards; falls back if needed. Deterministic via θ'-seeding.

## Two Parts (Integrated Script)
### 1. RSA Cert Harvester
- **Scan Logic**: Recursively walks from `root="/" ` using `os.walk`.
- **File Filters**: Extensions `.pem`, `.crt`, `.cer`, `.der`.
- **Cert Parsing**: Uses `cryptography.x509` to load PEM/DER; checks if public key is `rsa.RSAPublicKey`.
- **Extraction**: Gets modulus `n` (int), exponent `e` (int).
- **Naming**: Destination `~/.tears/{sha256(str(n))[:16]}_{n.bit_length()}bit.{ext}` to avoid collisions.
- **Copy**: `shutil.copy` original to dest; yields `(n, e, dest_path)` for Part 2.
- **Error Handling**: Silently skips invalid files via `try-except`.
- **Output**: Prints found certs with bit length and dest name.

### 2. Geometric Factorizer (GVA)
- **Constants**: `φ = (1 + √5)/2`, `e2 = exp(2)`.
- **Curvature κ(n)**: `4 * mp.ln(n+1) / e2`. Tunes max steps.
- **Resolution θ'(n, k=0.3)**: `mod = n % int(φ * 10007)`; return `float(φ * ( (mod / φ) ** k ))`. Generates seeds.
- **Z-Normalization**: `Z = Δn / Δmax`, `Δmax = mpf(2^(N.bit_length()//2)) / e2`; post-factor guard `if Z >=1: raise ValueError("Causality violation")`.
- **Factor Method (GVA)**:
  - Early exit if `sympy.isprime(N)`. 
  - Compute `sqrtN = int(mp.sqrt(N))`. 
  - Embed N in torus manifold with dims=9, k=0.3/log2(log2(N)). 
  - Search around sqrtN with range up to 10^6: for d in range, p=sqrtN+d, if N%p==0, q=N//p, check balance |log2(p/q)|<=1, embed p/q, compute Riemannian distance < ε, return (p,q).- **Fallback**: If no factor, use `sympy.factorint(N)` (may be slow for large N).
- **Integration**: After harvest, for each n, run `geometric_factor(n)`; print factors if found.

## Usage
- Run script: `python app-001.py`.
- Harvests and factors in one pass.
- For large N (>256-bit), may timeout; recommend high-perf libs (e.g., GMP via gmpy2, not installed here).
- Validation: Test on small known RSA moduli; check Z <1, κ >0.
- Extensions: Add multiprocessing for scan; integrate CADO-NFS for 256+ bit via subprocess (Z-tuned params).
```
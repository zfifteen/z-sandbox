        for (BigInteger p : candidates) {
            if (p.compareTo(BigInteger.ONE) <= 0 || p.compareTo(N) >= 0) continue;
            if (!N.mod(p).equals(BigInteger.ZERO)) continue;
            BigInteger q = N.divide(p);
            if (!isPrime(q)) continue;
            if (!isBalanced(p, q)) continue;

            // Embed factors and check distance
            BigDecimal[] emb_p = Embedding.embedTorusGeodesic(new BigDecimal(p), k, dims);
            BigDecimal[] emb_q = Embedding.embedTorusGeodesic(new BigDecimal(q), k, dims);
            BigDecimal dist_p = RiemannianDistance.calculate(emb_N, emb_p, N_bd);
            BigDecimal dist_q = RiemannianDistance.calculate(emb_N, emb_q, N_bd);
            BigDecimal minDist = dist_p.min(dist_q);

            if (minDist.compareTo(epsilon) < 0) {
                return new BigInteger[]{p, q};
            }

            // Optional: Try A* to find path to factor embedding
            List<BigDecimal[]> path = astar.findPath(emb_N, emb_p, N_bd, 10000);
            if (path != null && path.size() > 1) {
                // Check if path leads to factor recovery
                for (BigDecimal[] point : path) {
                    // Inverse embedding would be needed here, but simplified
                }
            }
        }

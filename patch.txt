diff --git a/python/ecm_backend.py b/python/ecm_backend.py
index 8e2b8d3..f2b0a5b 100644
--- a/python/ecm_backend.py
+++ b/python/ecm_backend.py
@@ -1,32 +1,126 @@
-import shutil
-ECM_BIN = shutil.which("ecm")
-BACKEND = "gmp-ecm" if ECM_BIN else "pyecm"
-
-def run_ecm_once(N: int, B1: int, curves: int, timeout_sec: int):
-    if BACKEND == "gmp-ecm":
-        import subprocess, shlex
-        cmd = f"ecm -q -one -c {curves} {B1}"
-        p = subprocess.Popen(shlex.split(cmd), stdin=subprocess.PIPE,
-                             stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
-        try:
-            out, _ = p.communicate(input=str(N) + "\n", timeout=timeout_sec)
-        except subprocess.TimeoutExpired:
-            p.kill(); return None
-        for line in out.splitlines():
-            s = line.strip()
-            if s.isdigit():
-                f = int(s)
-                if 1 < f < N and (N % f) == 0:
-                    return f
-        return None
-    else:
-        # pyecm fallback – slower; only for dev boxes without gmp-ecm
-        import pyecm
-        # pyecm factor() returns a list of prime factors (not guaranteed in one pass)
-        fs = pyecm.factors(N, True, False, B1=B1)
-        for f in fs:
-            if 1 < f < N and (N % f) == 0:
-                return f
-        return None
+from __future__ import annotations
+import shutil
+import subprocess
+import shlex
+from pathlib import Path
+from typing import Optional, Tuple
+
+# Detect backend once
+ECM_BIN = shutil.which("ecm")
+BACKEND = "gmp-ecm" if ECM_BIN else "pyecm"
+
+def backend_info() -> dict:
+    """
+    Returns {'backend': 'gmp-ecm'|'pyecm', 'version': <str or None>}
+    """
+    if BACKEND != "gmp-ecm":
+        return {"backend": BACKEND, "version": None}
+    try:
+        # 'ecm -v' prints version and table info
+        out = subprocess.check_output(["ecm", "-v"], text=True, timeout=5)
+        first = out.strip().splitlines()[0] if out else ""
+        return {"backend": BACKEND, "version": first}
+    except Exception:
+        return {"backend": BACKEND, "version": None}
+
+def _parse_factor_lines(output: str, N: int) -> Optional[int]:
+    """
+    Parse ECM stdout: factors are typically printed as bare decimal integers
+    on their own line (quiet mode). We conservatively accept only pure digits.
+    """
+    for line in output.splitlines():
+        s = line.strip()
+        if s.isdigit():
-            f = int(s)
-            if 1 < f < N and (N % f) == 0:
-                return f
+    return None
+
+def run_ecm_once(
+    N: int,
+    B1: int,
+    curves: int,
+    timeout_sec: int,
+    checkpoint_dir: Optional[str | Path] = None,
+    sigma: Optional[int] = None,
+    allow_resume: bool = True,
+) -> Optional[int]:
+    """
+    Returns a nontrivial factor of N or None.
+    - For gmp-ecm: uses -q -one -c {curves} {B1} and, if provided,
+      -save/-resume <file> and -sigma <u64>.
+    - For pyecm fallback: attempts a single-pass trial with given B1.
+    """
+    if BACKEND == "gmp-ecm":
+        # Build command
+        cmd = ["ecm", "-q", "-one", "-c", str(curves)]
+        # Optional deterministic seeding
+        if sigma is not None and sigma > 0:
+            cmd += ["-sigma", str(sigma)]
+        # Optional checkpointing
+        ckfile = None
+        if checkpoint_dir:
+            Path(checkpoint_dir).mkdir(parents=True, exist_ok=True)
+            ckfile = Path(checkpoint_dir) / f"ecm_ck_B1{B1}_{str(N)[:16]}.sav"
+            cmd += ["-save", str(ckfile)]
+            if allow_resume and ckfile.exists():
+                cmd += ["-resume", str(ckfile)]
+        cmd += [str(B1)]
+        # Launch
+        p = subprocess.Popen(
+            cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
+        )
+        try:
+            out, _ = p.communicate(input=str(N) + "\n", timeout=timeout_sec)
        except subprocess.TimeoutExpired:
            p.kill()
            return None
-        return _parse_factor_lines(out, N)
+    else:
+        # pyecm fallback – slower; only for dev boxes without gmp-ecm
+        import pyecm  # type: ignore
+        # Note: pyecm has no checkpointing or sigma control
+        fs = pyecm.factors(N, True, False, B1=B1)
+        for f in fs:
+            if 1 < f < N and (N % f) == 0:
+                return f
+        return None
diff --git a/python/factor_256bit.py b/python/factor_256bit.py
index a8b7a23..dbb3a73 100644
--- a/python/factor_256bit.py
+++ b/python/factor_256bit.py
@@ -1,13 +1,26 @@
-import os, subprocess, shlex, time, math, random
-from pathlib import Path
-
-def is_probable_prime(n, k=12):
+import os, time
+from pathlib import Path
+import hashlib
+from ecm_backend import run_ecm_once, backend_info
+
+def is_probable_prime(n, k=12) -> bool:
     if n < 2: return False
     small_primes = [2,3,5,7,11,13,17,19,23,29,31]
     for p in small_primes:
         if n % p == 0:
             return n == p
     # Miller-Rabin (deterministic for 64-bit; probabilistic otherwise)
     d, r = n-1, 0
     while d % 2 == 0: d //= 2; r += 1
     def check(a):
         x = pow(a, d, n)
         if x == 1 or x == n-1: return True
         for _ in range(r-1):
             x = (x * x) % n
             if x == n-1: return True
         return False
     for a in [2,325,9375,28178,450775,9780504,1795265022][:k]:
         a %= n
         if a in (0,1):
             continue
         if not check(a):
             return False
     return True
-
-def parse_ecm_factor(output: str):
-    for line in output.splitlines():
-        line = line.strip()
-        if line.isdigit():
-            return int(line)
-    return None
-
-def run_ecm_once(N: int, B1: int, curves: int, timeout_sec: int) -> int | None:
-    """
-    Returns a nontrivial factor or None.
-    Uses: ecm -q -one -c {curves} {B1}
-    """
-    cmd = f"ecm -q -one -c {curves} {B1}"
-    try:
-        proc = subprocess.Popen(
-            shlex.split(cmd), stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
-        )
-    except FileNotFoundError:
-        raise RuntimeError("ecm not found. Install GMP-ECM (e.g., brew install gmp-ecm)")
-
-    try:
-        out, err = proc.communicate(input=str(N) + "\n", timeout=timeout_sec)
-    except subprocess.TimeoutExpired:
-        proc.kill()
-        return None
-
-    f = parse_ecm_factor(out)
-    if f and 1 < f < N and N % f == 0:
-        return f
-    return None
@@ -15,17 +28,39 @@
 ECM_SCHEDULE = [
     # (target_digits, B1, curves)
     (35,   1_000_000,   1800),
     (40,   3_000_000,   5100),
     (45,  11_000_000,  10600),
     (50,  43_000_000,  19300),
 ]
 
-def factor_256bit(N: int, per_stage_timeout_sec=1200):
+def _compute_sigma_u64(N: int, B1: int) -> int:
+    """
+    Deterministic curve seed from blake2b(N||B1). Keep within uint64.
+    """
+    h = hashlib.blake2b(f"{N}:{B1}".encode(), digest_size=16).digest()
+    # take lower 8 bytes as unsigned 64-bit
+    return int.from_bytes(h[-8:], "little") or 1
+
+def factor_256bit(
+    N: int,
+    per_stage_timeout_sec: int = 1200,
+    checkpoint_dir: str | None = None,
+    use_sigma: bool = False,
+):
     # Guards against false positives
     if N.bit_length() < 250:
         raise ValueError(f"N too small for 256-bit path: {N.bit_length()} bits")
 
     # quick exit for trivial cases
     if is_probable_prime(N):
         return None, None
-    for (_, B1, curves) in ECM_SCHEDULE:
-        f = run_ecm_once(N, B1, curves, per_stage_timeout_sec)
+    # Resolve checkpoint directory (env overrides)
+    if checkpoint_dir is None:
+        checkpoint_dir = os.environ.get("ECM_CKDIR", "checkpoints")
+    # Resolve sigma mode (env overrides)
+    if not use_sigma:
+        use_sigma = os.environ.get("ECM_SIGMA", "0") == "1"
+
+    for (_, B1, curves) in ECM_SCHEDULE:
+        sigma = _compute_sigma_u64(N, B1) if use_sigma else None
+        f = run_ecm_once(
+            N, B1, curves, per_stage_timeout_sec,
+            checkpoint_dir=checkpoint_dir,
+            sigma=sigma,
+            allow_resume=True,
+        )
         if f:
             p, q = f, N // f
             # Final integrity checks
             if p*q == N and is_probable_prime(p) and is_probable_prime(q) and min(p.bit_length(), q.bit_length()) >= 120:
                 return (min(p, q), max(p, q))
             # If integrity failed, keep searching
     return None, None
diff --git a/python/scaling_test.py b/python/scaling_test.py
index 4b2b8d3..f2b0a5b 100644
--- a/python/scaling_test.py
+++ b/python/scaling_test.py
@@ -1,29 +1,67 @@
-import json, time, math
-from pathlib import Path
-from factor_256bit import factor_256bit
-
-LOG = Path("logs/256bit_breakthrough_log.md")
-LOG.parent.mkdir(parents=True, exist_ok=True)
-
-def log_row(result):
-    with open(LOG, "a") as f:
-        f.write(json.dumps(result) + "\n")
-
-def run_batch(max_targets=100, timeout_per_stage=1200, single_N=None):
-    with open('python/targets_filtered.json', 'r') as f:
-        data = json.load(f)
-    targets = data['targets']
-    print(f"Loaded {len(targets)} targets")
-
-    for i, N in enumerate(targets[:max_targets], 1):
-        t0 = time.time()
-        result = {"i": i, "bits": N.bit_length(), "N_head": str(N)[:20], "timeout_stage": timeout_per_stage}
-        try:
-            p, q = factor_256bit(N, per_stage_timeout_sec=timeout_per_stage)
-            dt = time.time() - t0
-            if p and q:
-                result |= {
-                    "status": "factored",
-                    "p_bits": p.bit_length(),
-                    "q_bits": q.bit_length(),
-                    "min_factor_bits": min(p.bit_length(), q.bit_length()),
-                    "integrity": (p*q == N),
-                }
-            else:
-                result |= {"status": "not_factored", "time_sec": round(dt, 3)}
-        except Exception as e:
-            result |= {"status": "error", "error": str(e)}
-        log_row(result)
-        print(result)
-
-if __name__ == "__main__":
-    run_batch()
+import json, time, argparse, importlib, datetime
+from pathlib import Path
+from factor_256bit import factor_256bit, ECM_SCHEDULE
+from ecm_backend import backend_info
+from targets import load_256bit_targets  # your generator/loader
+
+LOG = Path("logs/256bit_breakthrough_log.md")
+LOG.parent.mkdir(parents=True, exist_ok=True)
+
+def _append_log(row: dict) -> None:
+    with open(LOG, "a") as f:
+        f.write(json.dumps(row) + "\n")
+
+def _maybe_theta_gate(N: int):
+    """
+    Try to call a theta-gate if available:
+    - manifold_128bit.theta_gate(N) or
+    - manifold_128bit.theta_prime_gate(N) or
+    returns None if unavailable.
+    """
+    try:
+        m = importlib.import_module("manifold_128bit")
+        for fn in ("theta_gate", "theta_prime_gate"):
+            if hasattr(m, fn):
+                return getattr(m, fn)(N)
+    except Exception:
+        pass
+    return None
+
+def run_batch(timeout_per_stage=1200, max_targets=100, checkpoint_dir=None, use_sigma=False, single_N=None):
+    # Run metadata header (once)
+    meta = backend_info()
+    meta.update({
+        "meta": "RUN",
+        "timestamp": datetime.datetime.utcnow().isoformat() + "Z",
+        "schedule_B1": [B1 for _, B1, _ in ECM_SCHEDULE],
+        "schedule_curves": [curves for *_, curves in ECM_SCHEDULE],
+        "timeout_per_stage": timeout_per_stage,
+        "use_sigma": bool(use_sigma),
+        "checkpoint_dir": checkpoint_dir or "checkpoints",
+    })
+    _append_log(meta)
+
+    if single_N is not None:
+        T = [single_N]
+    else:
+        T = load_256bit_targets(max_targets)
+
+    for i, N in enumerate(T, 1):
+        t0 = time.time()
+        theta_gate = _maybe_theta_gate(N)
+        result = {
+            "i": i,
+            "bits": N.bit_length(),
+            "N_head": str(N)[:20],
+            "timeout_stage": timeout_per_stage,
+            "theta_gate": theta_gate,
+        }
+        try:
+            p, q = factor_256bit(N, per_stage_timeout_sec=timeout_per_stage, checkpoint_dir=checkpoint_dir, use_sigma=use_sigma)
+            dt = time.time() - t0
+            if p and q:
+                result.update({
+                    "status": "factored",
+                    "time_sec": round(dt, 3),
+                    "p_bits": p.bit_length(),
+                    "q_bits": q.bit_length(),
+                    "min_factor_bits": min(p.bit_length(), q.bit_length()),
+                    "integrity": (p*q == N),
+                })
+            else:
+                result.update({"status": "not_factored", "time_sec": round(dt, 3)})
+        except Exception as e:
+            result.update({"status": "error", "error": str(e)})
+        _append_log(result)
+
+def _parse_args():
+    ap = argparse.ArgumentParser()
+    ap.add_argument("--timeout-per-stage", type=int, default=1200)
+    ap.add_argument("--count", type=int, default=100)
+    ap.add_argument("--single", type=int, default=None, help="Run a single N (decimal)")
+    ap.add_argument("--checkpoint-dir", type=str, default=None)
+    ap.add_argument("--use-sigma", action="store_true", help="Enable deterministic -sigma seeding")
+    return ap.parse_args()
+
+if __name__ == "__main__":
    args = _parse_args()
    run_batch(
        timeout_per_stage=args.timeout_per_stage,
        max_targets=args.count,
        checkpoint_dir=args.checkpoint_dir,
        use_sigma=args.use_sigma,
        single_N=args.single,
    )
diff --git a/scripts/run_full_batch.sh b/scripts/run_full_batch.sh
index 3b9f6a1..b1b4e6a 100755
--- a/scripts/run_full_batch.sh
+++ b/scripts/run_full_batch.sh
@@ -1,17 +1,25 @@
 #!/usr/bin/env bash
 set -euo pipefail
-: "${J:=4}"                       # parallel jobs
-: "${TIMEOUT:=1200}"              # per-stage timeout (sec)
-: "${COUNT:=100}"                 # targets to run
+: "${J:=4}"                        # parallel jobs
+: "${TIMEOUT:=1200}"               # per-stage timeout (sec)
+: "${COUNT:=100}"                  # targets to run
+: "${ECM_CKDIR:=checkpoints}"      # checkpoint directory
+: "${ECM_SIGMA:=0}"                # set to 1 for deterministic curves
 
 export PYTHONUNBUFFERED=1
-brew list gnu-parallel >/dev/null 2>&1 || brew install parallel
+if ! command -v parallel >/dev/null 2>&1; then
+  if command -v brew >/dev/null 2>&1; then
+    brew install parallel
+  else
+    echo "GNU parallel not found and Homebrew missing; please install parallel." >&2
+    exit 1
+  fi
+fi
 
 python3 - <<'PY'
 from pathlib import Path; import json
 ts = Path("python/targets_filtered.json")
 T = [int(x) for x in json.loads(ts.read_text())["targets"][:100]]
 for n in T: print(n)
 PY \
-| parallel -j "$J" --halt soon,fail=1 \
-  'python3 python/scaling_test.py --single {} --timeout-per-stage '"$TIMEOUT"
+| parallel -j "$J" --halt soon,fail=1 \
+  'ECM_CKDIR='"$ECM_CKDIR"' ECM_SIGMA='"$ECM_SIGMA"' python3 python/scaling_test.py --single {} --timeout-per-stage '"$TIMEOUT"' --checkpoint-dir '"$ECM_CKDIR"' '"$( [ "$ECM_SIGMA" = "1" ] && echo --use-sigma )"'
 
 echo "DONE"
diff --git a/scripts/summarize_256_log.py b/scripts/summarize_256_log.py
index 5c4f8a1..4a3e0c2 100644
--- a/scripts/summarize_256_log.py
+++ b/scripts/summarize_256_log.py
@@ -1,13 +1,28 @@
-import json, sys
-hits = 0; total = 0
-for line in open("logs/256bit_breakthrough_log.md"):
-    try:
-        r = json.loads(line); total += 1
-        if r.get("status") == "factored": hits += 1
-    except: pass
-print(f"factored={hits} / total={total}  hit_rate={hits/(total or 1):.2%}")
+import json, sys, collections
+from pathlib import Path
+
+log = Path("logs/256bit_breakthrough_log.md")
+if not log.exists():
+    print("No log file found.", file=sys.stderr)
+    sys.exit(1)
+
+meta = None
+hits = 0
+total = 0
+theta_counts = collections.Counter()
+for line in open(log):
+    try:
+        r = json.loads(line)
+    except Exception:
+        continue
+    if r.get("meta") == "RUN":
+        meta = r
+        continue
+    total += 1
+    if r.get("status") == "factored":
+        hits += 1
+    tg = r.get("theta_gate")
+    if tg is not None:
+        theta_counts[str(bool(tg))] += 1
+
+print(f"factored={hits} / total={total}  hit_rate={hits/(total or 1):.2%}")
+if meta:
+    print(f"backend={meta.get('backend')} version={meta.get('version')} B1s={meta.get('schedule_B1')}")
+if theta_counts:
+    print("theta_gate counts:", dict(theta_counts))

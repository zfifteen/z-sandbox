// Focused on Adaptive Reps\n// Enhanced Prime Generator Demonstration
// Shows the three key optimizations implemented per issue requirements

#include <stdio.h>
#include <time.h>
#include <gmp.h>
#include "z5d_predictor.h"

static double get_time_ms() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000.0 + ts.tv_nsec / 1e6;
}

int main() {
    printf("Prime Generator Enhancement Demonstration\n");
    printf("=======================================\n\n");
    
    printf("Issue #767 Requirements Implemented:\n");
    printf("1. Z5D Jump Function - Using prime-density model predictions\n");
    printf("2. Adaptive reps count - Dynamic Miller-Rabin repetitions\n");
    printf("3. Pre-filtering optimization - Quick mpz_probab_prime_p(n,1) test\n\n");
    
    // Demonstrate adaptive reps count
    printf("FEATURE 1: Adaptive Reps Count\n");
    printf("------------------------------\n");
    mpz_t test_nums[4];
    const char* labels[4] = {"64-bit", "256-bit", "1024-bit", "4096-bit"};
    
    mpz_init_set_str(test_nums[0], "18446744073709551557", 10);  // 64-bit prime
    mpz_init_set_str(test_nums[1], "115792089237316195423570985008687907853269984665640564039457584007913129639747", 10);  // 256-bit
    mpz_init_set_str(test_nums[2], "1" "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007", 10);  // ~1024-bit
    mpz_init_set_str(test_nums[3], "1" "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007", 10);  // ~4096-bit
    
    for (int i = 0; i < 4; i++) {
        size_t bit_length = mpz_sizeinbase(test_nums[i], 2);
        int reps = (bit_length < 64) ? 5 : (bit_length < 256) ? 10 : (bit_length < 1024) ? 15 : (bit_length < 4096) ? 25 : 50;
        
        printf("  %s number (%zu bits): %d reps\n", labels[i], bit_length, reps);
        
        double t1 = get_time_ms();
        int result = mpz_probab_prime_p(test_nums[i], reps);
        double time_adaptive = get_time_ms() - t1;
        
        double t2 = get_time_ms();
        int result_fixed = mpz_probab_prime_p(test_nums[i], 25);  // Fixed 25 reps
        double time_fixed = get_time_ms() - t2;
        
        printf("    Adaptive (%d reps): %.3f ms, Fixed (25 reps): %.3f ms\n", 
               reps, time_adaptive, time_fixed);
